{% import 'default_msg_strategies.python.jinja' as msgs %}

{##############################################################################}
{# Constants and Utility #}
{##############################################################################}

{% set TIME_INF = 1000 %}
{% set MAX_SPAM = 3 %}
{% set MIN_TICK = 10 %} {# ms #}

{% macro _ordinal(n) -%}
  {% if n == 11 or n == 12 or n == 13 -%}
    {{ n }}th
  {%- elif n % 10 == 1 -%}
    {{ n }}st
  {%- elif n % 10 == 2 -%}
    {{ n }}nd
  {%- elif n % 10 == 3 -%}
    {{ n }}rd
  {%- else -%}
    {{ n }}th
  {%- endif %}
{%- endmacro %}


{##############################################################################}
{# Event Generation #}
{##############################################################################}

{#
  Generation of mandatory and spam events.
  Places generated messages in the trace, in order.
  Assumes that mandatory timestamps have been pre-generated.
#}
{% macro _handle_segments(schema) -%}
{% for segment in schema.segments %}
# ---- {{ _ordinal(loop.index) }} trace segment ----
{{ _gen_mandatory_events(segment.published, loop.index0) }}
{{ _gen_spam_events(segment.spam.values(), schema, loop.index0) }}
{% endfor %}
{%- endmacro %}


{#
  Generates mandatory events.
  First event uses the generated timestamp.
  Further events are placed at +0 from the first one,
#}
{% macro _gen_mandatory_events(published, i) -%}
# ---- mandatory events ----
{% for msg_strategy in published %}
{{ _gen_msg(msg_strategy) }}{# -#}
  {% if loop.first %}
rec = MsgRecord('{{ msg_strategy.topic }}', timestamps[{{ i }}], msg)
  {% else %}
rec = MsgRecord('{{ msg_strategy.topic }}', 0, msg)
  {% endif %}
{# -#}
trace.append(rec){# -#}
{% else %}
# There are no mandatory events.{# -#}
{% endfor %}
{%- endmacro %}


{#
  Generates spam events.
  Builds a list of messages and then gradually "spends" the
    available time between the current and the next trace segments.
#}
{% macro _gen_spam_events(spam_strategies, schema, i) -%}
# ---- spam events ----
{% if spam_strategies|length == 0 -%}
# There are no spam events.{# -#}
{%- else -%}
spam = draw({{ _spam_name(schema, i) }}(trace))
for msg, topic in spam:
    if timestamps[{{ i + 1 }}] < {{ MIN_TICK }}:
        timestamp = 0
    else:
        timestamp = draw(strategies.sampled_from(0, {{ MIN_TICK }}, {# -#}
            timestamps[{{ i + 1 }}]))
    timestamps[{{ i + 1 }}] -= timestamp
    rec = MsgRecord(topic, timestamp, msg)
    trace.append(rec)
{%- endif %}{# -#}
{%- endmacro %}


{# Generates a message, given a message strategy. #}
{% macro _gen_msg(msg_strategy) -%}
{% if msg_strategy.is_default %}
    {% set fun = msgs.strategy_name(msg_strategy.pkg, msg_strategy.msg) %}
{% else %}
    {% set fun = msg_strategy.name %}
{% endif %}
msg = draw({{ fun }}(trace=trace))
{% if msg_strategy.alias -%}
trace.msg_{{ msg_strategy.alias }} = msg
{%- endif %}
{%- endmacro %}


{##############################################################################}
{# Timestamp Allocation #}
{##############################################################################}

{#
  Allocation of mandatory timestamps.
  One timestamp per schema time interval, plus an 'infinity' at the end.
  The additional timestamp is required for spam placement.
#}
{% macro _allocate_timestamps(schema) -%}
# ---- timestamp allocation ----
timestamps = []
{% for segment in schema.segments %}
{{ _gen_timestamp(segment) }}
timestamps.append(timestamp)
{% endfor %}
timestamps.append({{ TIME_INF }})
{%- endmacro %}


{#
  Generates a strategy for a timestamp, given lower and upper bounds.
  Unbounded intervals are limited to a default upper bound.
  Optimization: sample only from a few key values in the interval.

  TODO: options to control sampling granularity.
#}
{% macro _gen_timestamp(segment) -%}
{% if segment.is_bounded -%}
    {% set max_time = segment.upper_bound %}
{%- elif segment.lower_bound >= TIME_INF -%}
    {% set max_time = 2 * segment.lower_bound %}
{%- else -%}
    {% set max_time = TIME_INF %}
{%- endif %}
{% set delta = max_time - segment.lower_bound %}
{% if delta <= 1 -%}
timestamp = {{ segment.lower_bound }}
{%- else -%}
timestamp = draw(strategies.sampled_from(({# -#}
    {{ segment.lower_bound }}, {# -#}
    {% if delta > 2 -%}
    {{ segment.lower_bound + (delta // 2) }}, {# -#}
    {%- endif -%}
    {{ max_time - 1 }}{# -#}
)))
{%- endif %}
{%- endmacro %}


{##############################################################################}
{# Unified Spam Strategies #}
{##############################################################################}

{% macro _spam_name(schema, i) -%}
spam_{{ schema.name }}_{{ i }}
{%- endmacro %}

{% macro _unified_spam_strategies(schema) %}
  {% for segment in schema.segments %}
    {% set n = segment.spam|length %}
    {% if n == 1 %}
@strategies.composite
def {{ _spam_name(schema, loop.index0) }}(draw, trace):
    return draw(strategies.lists(strategies.tuples(
      {% for msg_strategy in segment.spam.values() %}
        {% if not msg_strategy.is_default %}
        {{ msg_strategy.name }}(trace=trace),
        {% else %}
        {{ msgs.strategy_name(msg_strategy.pkg, msg_strategy.msg) }}(),
        {% endif %}
        strategies.just('{{ msg_strategy.topic }}')
      {% endfor %}
    ), min_size=0, max_size={{ MAX_SPAM }}))

    {% elif n > 1 %}
{# go for custom first, then go for default msgs #}
{{ _spam_name(schema, loop.index0) }}_elems = strategies.sampled_from((
      {% for msg_strategy in segment.spam.values() %}
        {% if not msg_strategy.is_default %}
    ({{ msg_strategy.name }}, '{{ msg_strategy.topic }}'),
        {% endif %}
      {% endfor %}
      {% for msg_strategy in segment.spam.values() %}
        {% if msg_strategy.is_default %}
    ({{ msgs.strategy_name(msg_strategy.pkg, msg_strategy.msg) }}, {# -#}
      '{{ msg_strategy.topic }}'),
        {% endif %}
      {% endfor %}
))

@strategies.composite
def {{ _spam_name(schema, loop.index0) }}(draw, trace):
    spam = draw(strategies.lists({# -#}
        {{ _spam_name(schema, loop.index0) }}_elems, {# -#}
        min_size=0, max_size={{ MAX_SPAM }}))
    for i in range(len(spam)):
        msg_strat, topic = spam[i]
        spam[i] = (draw(msg_strat(trace=trace)), topic)
    return spam

    {% endif %}
  {% endfor %}
{% endmacro %}

{##############################################################################}
{# Template Body #}
{##############################################################################}

{# receives:
    schemas: [SchemaInfo]
    aliases: [string]
#}

{# SchemaInfo:
    name: string
    segments: [TraceSegment]
    text: string
#}

{# TraceSegment:
    lower_bound: int
    upper_bound: int
    published: [MsgStrategy]
    spam: {topic: MsgStrategy}
    is_single_instant: bool
    is_bounded: bool
#}


class Trace(object):
    __slots__ = (
        'schema', # int
        'events', # [MsgRecord]
{% for alias in aliases %}
        'msg_{{ alias }}', # MsgRecord
{% endfor %}
    )

    def __init__(self, events=None, schema=None):
        self.schema = schema
        self.events = events if events is not None else []
{% for alias in aliases %}
        self.msg_{{ alias }} = None
{% endfor %}

    @property
    def first(self):
        return None if not self.events else self.events[0]

    @property
    def last(self):
        return None if not self.events else self.events[-1]

    @property
    def n_messages(self):
        return len(self.events)

    def append(self, event):
        self.events.append(event)

    def __len__(self):
        return len(self.events)

    def __iter__(self):
          return iter(self.events)

    def __str__(self):
        parts = []
        for event in self.events:
            parts.append("+{} '{}':\n{}".format(event.timestamp,
                event.topic, event.msg))
        return '\n'.join(parts)

    def __repr__(self):
        return "Trace(events={!r}, schema={!r})".format(
            self.events, self.schema)

{% for schema in schemas %}

################################################################################
# {{ _ordinal(loop.index) }} Trace Schema
################################################################################

{{ _unified_spam_strategies(schema) }}
'''
{{ schema.text }}
'''
@strategies.composite
def schema_{{ schema.name }}(draw):
    trace = Trace(schema={{ loop.index }})
{{ _allocate_timestamps(schema)|indent(4, first=true) }}
{{ _handle_segments(schema)|indent(4, first=true) }}{#- #}
    return trace
{% endfor %}


traces = strategies.one_of((
{% for schema in schemas %}
    schema_{{ schema.name }}(),
{% endfor %}
))
