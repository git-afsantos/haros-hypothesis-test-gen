{% import 'default_msg_strategies.python.jinja' as msgs %}

{% set TIME_INF = 1000 %}
{% set MAX_SPAM = 3 %}

{% macro _ordinal(n) -%}
  {% if n == 11 or n == 12 or n == 13 -%}
    {{ n }}th
  {%- elif n % 10 == 1 -%}
    {{ n }}st
  {%- elif n % 10 == 2 -%}
    {{ n }}nd
  {%- elif n % 10 == 3 -%}
    {{ n }}rd
  {%- else -%}
    {{ n }}th
  {%- endif %}
{%- endmacro %}


{# Generation of Random messages. #}
{% macro _gen_spam(spam) -%}
# ----- Spam ------------------------------------------
all_msgs = []
{% for strategy in spam %}
    {% if strategy.is_default %}
elems = {{ msgs.strategy_name(strategy.pkg, strategy.msg) }}()
    {% else %}
elems = {{ strategy.name }}({{ strategy.args|join(', ') }})
    {% endif %}
elems = strategies.tuples(elems, strategies.just("{{ strategy.topic }}"))
all_msgs.extend(draw(strategies.lists(elems, min_size=0, max_size=3)))
{% endfor %}
{%- endmacro %}


{% macro gen_spam_chunks(spam) -%}
{% if spam %}
{{ _gen_spam(spam) }}
if all_msgs:
    r.shuffle(all_msgs)
    chunks.extend(draw(chunk_splits(all_msgs)))
{% else %}
# There are no strategies for random messages.
{% endif %}
{%- endmacro %}


{% macro gen_activator(p) -%}
{% if p.spam %}
{{ _gen_spam(p.spam) }}
if all_msgs:
    r.shuffle(all_msgs)
    chunks.extend(draw(chunk_splits(all_msgs)))
else:
    chunks.append(Chunk())
{% else %}
# There are no strategies for random messages.
chunks.append(Chunk())
{% endif %}
# ----- Activator -------------------------------------
{% if p.strategy.name == '_' %}
for _chunk in chunks:
    _chunk.req_not_scope = True
# Activator is sent by the SUT.
chunks.append(Chunk())
chunks[-1].req_scope = True
chunks[-1].set_clock = True
{% else %}
    {% if p.strategy.is_default %}
        {% set strategy = msgs.strategy_name(p.strategy.pkg, p.strategy.msg) %}
        {% set args = '' %}
    {% else %}
        {% set strategy = p.strategy.name %}
        {% set args = p.strategy.args|join(', ') %}
    {% endif %}
msg = (draw({{ strategy }}({{ args }})), "{{ p.strategy.topic }}")
    {% if p.strategy.alias %}
msg_{{ p.strategy.alias }} = msg[0]
    {% endif %}
chunks[-1].messages.append(msg)
chunks[-1].set_clock = True
for _chunk in chunks:
    _chunk.req_not_scope = True
{% endif %}
{%- endmacro %}


{% macro gen_terminator(q, min_delay, max_delay) -%}
{{ gen_delay_chunk(min_delay, max_delay, relative_delay=true) }}
{% if q.spam %}
{{ _gen_spam(q.spam) }}
if all_msgs:
    r.shuffle(all_msgs)
    chunk.messages.extend(all_msgs)
{% else %}
# There are no strategies for random messages.
{% endif %}
# ----- Terminator ------------------------------------
{% if q.strategy.name == '_' %}
chunk.req_scope = True
# Terminator is sent by the SUT.
chunks.append(Chunk())
chunks[-1].req_not_scope = True
{% else %}
    {% if q.strategy.is_default %}
        {% set strategy = msgs.strategy_name(q.strategy.pkg, q.strategy.msg) %}
        {% set args = '' %}
    {% else %}
        {% set strategy = q.strategy.name %}
        {% set args = q.strategy.args|join(', ') %}
    {% endif %}
msg = (draw({{ strategy }}({{ args }})), "{{ q.strategy.topic }}")
chunk.messages.append(msg)
chunk.req_scope = True
{% endif %}
{%- endmacro %}


{% macro gen_delay_chunk(min_delay, max_delay, relative_delay=true) -%}
chunk = Chunk()
{% if relative_delay %}
chunk.relative_delay = True
{% else %}
chunk.relative_delay = False
{% endif %}
{% if min_delay != max_delay %}
chunk.delay = draw(strategies.sampled_from(({{ min_delay }}, {{ max_delay }})))
{% else %}
chunk.delay = {{ min_delay }}
{% endif %}
chunks.append(chunk)
{%- endmacro %}


{% macro gen_triggers(a, b) -%}
{% if a.strategy.is_default %}
    {% set strategy = msgs.strategy_name(a.strategy.pkg, a.strategy.msg) %}
    {% set args = '' %}
{% else %}
    {% set strategy = a.strategy.name %}
    {% set args = a.strategy.args|join(', ') %}
{% endif %}
# ----- Trigger ---------------------------------------
elems = strategies.tuples({{ strategy }}({{ args }}), strategies.just("{{ a.strategy.topic }}"))
triggers = draw(strategies.lists(elems, min_size={{ a.min_num }}, max_size={{ a.max_num }}))
{% if a.min_num > 0 %}
new_chunks = draw(chunk_splits(triggers))
chunks.extend(new_chunks)
delays = strategies.sampled_from((0.0, {{ b.timeout }}))
for chunk in new_chunks:
    chunk.relative_delay = True
    chunk.delay = draw(delays)
    chunk.set_clock = True
    chunk.contains_trigger = True
    chunk.req_scope = True
    {% if a.spam %}
{{ _gen_spam(a.spam) }}
if all_msgs:
    r.shuffle(all_msgs)
    i = 0
    for msg in all_msgs:
        new_chunks[i].messages.append(msg)
        i = (i + 1) % len(new_chunks)
    {% endif %}
{% else %}{# a.min_num == 0 #}
if triggers:
    new_chunks = draw(chunk_splits(triggers))
    chunks.extend(new_chunks)
    delays = strategies.sampled_from((0.0, {{ b.timeout }}))
    for chunk in new_chunks:
        chunk.relative_delay = True
        chunk.delay = draw(delays)
        chunk.set_clock = True
        chunk.req_scope = True
    {% if a.spam %}
{{ _gen_spam(a.spam)|indent(width=4, first=true) }}
    if all_msgs:
        r.shuffle(all_msgs)
        i = 0
        for msg in all_msgs:
            new_chunks[i].messages.append(msg)
            i = (i + 1) % len(new_chunks)
    {% endif %}
{% endif %}
{%- endmacro %}





{# Generates a message, given a message strategy. #}
{% macro _gen_msg(msg_strategy) -%}
{% if msg_strategy.is_default %}
    {% set fun = msgs.strategy_name(msg_strategy.pkg, msg_strategy.msg) %}
    {% set args = '' %}
{% else %}
    {% set fun = msg_strategy.name %}
    {% set args = msg_strategy.args|join(', ') %}
{% endif %}
msg = draw({{ fun }}({{ args }}))
{% if msg_strategy.alias %}
msg_{{ msg_strategy.alias }} = msg
{% endif %}
{%- endmacro %}


{# FIXME: this should be `strategies.one_of`, but we must fix the args #}
{% macro _spam_union_strategy(spam_strategies) -%}
spam_strategies = (
{# go for defaults first #}
{% for msg_strategy in spam_strategies %}
  {% if msg_strategy.is_default %}
    {{ msgs.strategy_name(msg_strategy.pkg, msg_strategy.msg) }},
  {% endif %}
{% endfor %}
{# then go for custom msgs #}
{% for msg_strategy in spam_strategies %}
  {% if not msg_strategy.is_default %}
    {{ msg_strategy.name }},
  {% endif %}
{% endfor %}
)
n = draw(strategies.integers(min_value=0, max_value={{ MAX_SPAM + 1 }}))
for i in range(n):
    k
{%- endmacro %}


{#
  Generates spam events.
  Builds a list of messages and then gradually "spends" the
    available time between the previous and the next mandatory events.
#}
{% macro _gen_spam_events(spam_strategies, i) -%}
# ---- spam events ----
{% if len(spam_strategies) == 0 -%}
# There are no spam events.
{%- elif len(spam_strategies) == 1 -%}
{# TODO #}
{%- else -%}
{# TODO #}
{%- endif %}
{%- endmacro %}


{#
  Generates mandatory events.
  First event uses the generated timestamp.
  Further events are placed at +0 from the first one,
#}
{% macro _gen_mandatory_events(published, i) -%}
# ---- mandatory events ----
{% for msg_strategy in published %}
{{ _gen_msg(msg_strategy) }}
  {% if loop.first %}
rec = MsgRecord('{{ msg_strategy.topic }}', timestamps[{{ i }}], msg)
  {% else %}
rec = MsgRecord('{{ msg_strategy.topic }}', 0, msg)
  {% endif %}
trace.append(rec)
{% else %}
# There are not mandatory events.
{% endfor %}
{%- endmacro %}


{#
  Generates a strategy for a timestamp, given lower and upper bounds.
  Unbounded intervals are limited to a default upper bound.
  Optimization: sample only from a few key values in the interval.

  TODO: options to control sampling granularity.
#}
{% macro _gen_timestamp(segment) -%}
{% if segment.is_bounded -%}
    {% set max_time = segment.upper_bound %}
{%- elif segment.lower_bound >= TIME_INF -%}
    {% set max_time = 2 * segment.lower_bound %}
{%- else -%}
    {% set max_time = TIME_INF %}
{%- endif %}
{% set delta = max_time - segment.lower_bound %}
{% if delta <= 1 -%}
timestamp = {{ segment.lower_bound }}
{%- else -%}
timestamp = draw(strategies.sampled_from(({# -#}
    {{ segment.lower_bound }}, {# -#}
    {% if delta > 2 -%}
    {{ segment.lower_bound + (delta // 2) }}, {# -#}
    {%- endif %}
    {{ max_delay - 1 }}{# -#}
)))
{%- endif %}
{%- endmacro %}

{#
  Generation of mandatory and spam events.
  Places generated messages in the trace, in order.
  Assumes that mandatory timestamps have been pre-generated.
#}
{% macro _handle_segments(segments) -%}
{% for segment in segments %}
# ---- {{ _ordinal(loop.index) }} trace segment ----
{{ _gen_mandatory_events(segment.published, loop.index0) }}
{{ _gen_spam_events(segment.spam.values(), loop.index0) }}
{% endfor %}
{%- endmacro %}


{#
  Allocation of mandatory timestamps.
  One timestamp per schema time interval, plus an 'infinity' at the end.
  The additional timestamp is required for spam placement.
#}
{% macro _allocate_timestamps(segments) -%}
# ---- timestamp allocation ----
timestamps = []
{% for segment in segments %}
{{ _gen_timestamp(segment) }}
timestamps.append(timestamp)
{% endfor %}
timestamps.append({{ TIME_INF }})
{%- endmacro %}


{##############################################################################}
{# Template Body #}
{##############################################################################}

{# receives:
    schemas: [SchemaInfo]
#}

{# SchemaInfo:
    name: string
    segments: [TraceSegment]
    text: string
#}

{# TraceSegment:
    lower_bound: int
    upper_bound: int
    published: [MsgStrategy]
    spam: {topic: MsgStrategy}
    is_single_instant: bool
    is_bounded: bool
#}

{% for schema in schemas %}

'''
{{ schema.text }}
'''

@strategies.composite
def schema_{{ schema.name }}(draw):
    trace = []
{{ _allocate_timestamps(schema.segments)|indent(4, first=true) }}
{{ _handle_segments(schema.segments)|indent(4, first=true) }}
    return trace
{% endfor %}
