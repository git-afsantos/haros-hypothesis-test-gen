{# SPDX-License-Identifier: MIT #}
{# Copyright © 2021 André Santos #}

{##############################################################################}
{# Constants #}
{##############################################################################}

{% set MINI_RUN_EXAMPLES = 10 %}

{##############################################################################}
{# Test Case Macros #}
{##############################################################################}

{% macro _unittest_setup(publishers, subscribers, main_monitor) %}
def setUp(self):
    unittest.TestCase.setUp(self)
    self.trace_start_time = 0
    uuid = rospy.get_param("/run_id")
    {# uuid = roslaunch.rlutil.get_or_generate_uuid(None, True) #}
    roslaunch.configure_logging(uuid)
    self.launches = []
    self.monitors = []
    self.axioms = []
    self.subs = {}
    {% for sub in subscribers %}
        {% if sub.fake %}
    self.subs["{{ sub.topic }}"] = FakeTestSubscriber("{{ sub.topic }}")
        {% else %}
    self.subs["{{ sub.topic }}"] = TestSubscriber("{{ sub.topic }}", {# -#}
        {{ sub.type_token.type_name.replace("/", ".") }})
        {% endif %}
    {% endfor %}
    self.pubs = {}
    {% for pub in publishers %}
    self.pubs["{{ pub.topic }}"] = TestPublisher("{{ pub.topic }}", {# -#}
        {{ pub.rospy_type }}, self.subs["{{ pub.topic }}"])
    {% endfor %}
    self.n_examples = 0
    self.n_failed_assumptions = 0
    self.first_fail = None
    self.n_shrinks = 0
    self.counterexample_size = None
    self.n_fail = 0
    self.total_time = 0.0
    self.avg_time_example = 0.0
    self.avg_time_trace = 0.0
    self.avg_time_setup = 0.0
    self.json_stats = {
        "num_examples": None,
        "num_failures": None,
        "first_failure": None,
        "num_invalid": None,
        "num_shrinks": None,
        "avg_time_example": None,
        "avg_time_trace": None,
        "avg_time_setup": None,
        "size_counterexample": None,
        "property": "{{ main_monitor.hpl_string }}",
        "script": __file__,
    }
{% endmacro %}

{% macro _setup_test(main_monitor, monitors, axioms) %}
def _setup_test(self):
    self.trace_start_time = 0
    self.launch_time = 0
    self.deadline = 0
    self.monitors = []
    {% for monitor in monitors %}
    m = {{ monitor.class_name }}()
    self.monitors.append(m)
        {% if monitor.class_name == main_monitor %}
    self.main_monitor = m
    m.on_enter_scope = self._on_enter_scope
    m.on_exit_scope = self._on_exit_scope
    m.on_success = self._on_early_success
        {% endif %}
    m.on_violation = partial(self._on_property_violation, m, False)
        {% set registered = [] %}
        {% for event in monitor.events %}
            {% if not event.topic in registered %}
                {% set _x = registered.append(event.topic) %}
    self.subs["{{ event.topic }}"].add(m.on_msg_{{ event.topic.replace('/', '_')}})
            {% endif %}
        {% endfor %}
    {% endfor %}
    self.axioms = []
    {% for monitor in axioms %}
    m = {{ monitor.class_name }}()
    self.axioms.append(m)
    m.on_violation = partial(self._on_property_violation, m, True)
        {% set registered = [] %}
        {% for event in monitor.events %}
            {% if not event.topic in registered %}
                {% set _x = registered.append(event.topic) %}
    self.subs["{{ event.topic }}"].add(m.on_msg_{{ event.topic.replace('/', '_')}})
            {% endif %}
        {% endfor %}
    {% endfor %}
    self.launches = []
    self.trace_done = False
    self.assumptions_ok = True
    self.witness = None
    self.pub_log = []
    self.n_scopes = 0
    self.monitor_active = False
    self.fail_time = None
{% endmacro %}


{% macro _setup_sut(commands, settings) %}
def _setup_sut(self):
    global test_status_message
    test_status_message = 'Launching'
    self.launch_time = get_time()
    self.deadline = self.launch_time + {# defaults to 15 seconds -#}
        {{ settings['deadline']|d(15, true) }}
    for monitor in self.monitors:
        monitor.on_launch(self.launch_time)
    for monitor in self.axioms:
        monitor.on_launch(self.launch_time)
    with HiddenPrints():
    {% for cmd in commands %}
        {# uuid = rospy.get_param("/run_id") #}
        uuid = roslaunch.rlutil.get_or_generate_uuid(None, True)
        {% if cmd.command == 'roslaunch' %}
        launch = roslaunch.parent.ROSLaunchParent(uuid,
            ["{{ cmd.args[0] }}"],
            is_core=False, verbose=False)
        launch.start(auto_terminate=False)
        {% elif cmd.command == 'rosrun' %}
        launch = roslaunch.parent.ROSLaunchParent(uuid, [],
            is_core=False, verbose=False)
            {% if cmd.args|length >= 3 %}
        node = roslaunch.core.Node("{{ cmd.args[0] }}", "{{ cmd.args[1] }}",
            name="{{ cmd.args[2] }}")
            {% else %}
        node = roslaunch.core.Node("{{ cmd.args[0] }}", "{{ cmd.args[1] }}")
            {% endif %}
        launch.start()
        process, success = launch.runner.launch_node(node)
    if not success:
        raise RuntimeError("failed to launch {{ cmd.args[0] }}/{# -#}
            {{ cmd.args[1] }}")
        {% endif %}
    self.launches.append(launch)
    {% endfor %}
    self._wait_for_nodes()
    self._wait_for_interfaces()
{% endmacro %}


{% macro _test_hypothesis(settings, schemas) %}
{% set n = schemas|length %}
def _test_hypothesis_properties(self):
    if mode_random:
        print("[Test Schemas]: Selecting schemas at random")
        self._test_random_schema()
    else:
{% for schema in schemas %}
        # print("[Schema {{ loop.index }}/{{ n }}]")
        self._test_schema_{{ schema.name }}()
{% endfor %}

COMMON_HYPOTHESIS_SETTINGS = {
    'max_examples': {{ settings['max_examples']|d(100, true) }},
    'deadline': None,
    'suppress_health_check': (
        HealthCheck.filter_too_much,
        HealthCheck.too_slow,
    ),
}

@settings(**COMMON_HYPOTHESIS_SETTINGS)
@given(trace=traces)
def _test_random_schema(self, trace):
    try:
        self._run_example(trace)
    except UnstuckRequestError:
        print("[Unstuck Request]")
{% for schema in schemas %}

@settings(**COMMON_HYPOTHESIS_SETTINGS)
@given(trace=schema_{{ schema.name }}())
def _test_schema_{{ schema.name }}(self, trace):
    try:
        self._run_example(trace)
    except UnstuckRequestError:
        print("[Unstuck Request]")
{% endfor %}
{% endmacro %}


{# FIXME old code, not yet reused #}
{% macro _check_outcome(is_liveness) %}
def _check_outcome(self, trace):
    now = get_time()
    if trace.ends_via_timeout:
    {% if is_liveness %}
        if trace.n_triggers > 0 and not self.main_monitor.triggered:
            raise BuggyTestError.missing_trigger()
        if not self.main_monitor.at_least_once:
            raise InconclusiveTestError.timeout()
    {% endif %}
        if self.main_monitor.active:
            self.main_monitor._deactivate(now)
    else:
    {% if is_liveness %}
        if self.main_monitor.slack_max_time < inf:
            while self.main_monitor.active and self.main_monitor.slack_max_time >= now:
                rospy.sleep(self.main_monitor.slack_max_time - now)
                now = get_time()
                self.main_monitor.update(now)
    {% endif %}
        if self.main_monitor.active:
            raise BuggyTestError.missing_terminator()
    {% if is_liveness %}
        if trace.n_triggers > 0 and not self.main_monitor.triggered:
            raise BuggyTestError.missing_trigger()
        assert self.main_monitor.at_least_once, self.main_monitor.HPL_PROPERTY
    {% endif %}
    assert not self.main_monitor.has_failed, self.main_monitor.HPL_PROPERTY
{% endmacro %}


{% macro _eval_trace(axioms) %}
def _eval_trace(self, trace):
{% if axioms %}
    try:
    {% for monitor in axioms %}
        assume(eval_{{ monitor.class_name }}(trace))
    {% endfor %}
    except UnsatisfiedAssumption as e:
        self.assumptions_ok = False
        raise e
{% else %}
    pass
{% endif %}
{% endmacro %}


{##############################################################################}
{# RENDERED CODE #}
{##############################################################################}

{#
    Builds the main test case class, which contains the main logic of the test.
    It is responsible for setting up and tearing down the SUT, building
    the various property monitors and replaying a random trace given by
    hypothesis.
#}

{#
    expects:
        main_monitor, monitors, axioms, publishers,
        subscribers, commands, nodes, settings, is_liveness
#}

class EarlySuccess(Exception):
    pass


class TestTracer(unittest.TestCase):
    NODES = {{ nodes }}

    output_json = False
    output_csv = False

{{ _unittest_setup(publishers, subscribers, main_monitor)|indent(width=4, first=true) }}

    def tearDown(self):
        unittest.TestCase.tearDown(self)
        for sub in self.subs.values():
            sub.unregister()
        self.subs = {}
        for pub in self.pubs.values():
            pub.unregister()
        self.pubs = {}

    def test_properties(self):
        # test once that the SUT is OK, before Hypothesis begins its loop
        global test_status_message
        global test_status_running
        test_status_running = True
        test_status_message = 'Start'
        try:
            self._setup_sut()
            rospy.sleep(1.0)
        finally:
            self._teardown_sut()
            rospy.sleep(1.0)
        try:
            self.n_examples = 0
            self.n_fail = 0
            self.n_failed_assumptions = 0
            self.n_shrinks = 0
            self._test_hypothesis_properties()
        finally:
            test_status_running = False
            test_status_message = 'Statistics'
            if self.first_fail is not None:
                self.n_shrinks = self.n_examples - self.first_fail
            self.json_stats = {
                "num_examples": self.n_examples,
                "num_failures": self.n_fail,
                "first_failure": self.first_fail,
                "num_invalid": self.n_failed_assumptions,
                "num_shrinks": self.n_shrinks,
                "avg_time_example": self.avg_time_example,
                "avg_time_trace": self.avg_time_trace,
                "avg_time_setup": self.avg_time_setup,
                "size_counterexample": self.counterexample_size,
            }
            if self.n_examples > 0:
                print("Avg. test time:", self.avg_time_example)
                print("Total time:", self.total_time)
            print("Number of examples: {} ({} failures)".format(
                self.n_examples, self.n_fail))
            print("Number of failed assumptions: {}".format(
                self.n_failed_assumptions))
            if self.first_fail is not None:
                print("First failure at example #{} ({} shrink attempts)".format(
                    self.first_fail, self.n_shrinks))
                print("Counterexample trace size: {} messages".format(
                    self.counterexample_size))
            if self.output_json:
                self._write_json_output()
            if self.output_csv:
                self._write_csv_output()

{{ _test_hypothesis(settings, schemas)|indent(width=4, first=true) }}

    def _run_example(self, trace):
        if rospy.is_shutdown():
            return
        global request_unstuck
        global test_status_message
        test_status_message = 'Example #{} - Eval Trace'.format(self.n_examples + 1)
        self._eval_trace(trace)
        passed = False
        self.n_examples += 1
        test_status_message = 'Example #{} - Setup'.format(self.n_examples + 1)
        self._setup_test()
        print("[Example #{}]: Selected schema #{}".format(
            self.n_examples, trace.schema))
        print("[Example #{}]: Launching SUT...".format(self.n_examples))
        self._setup_sut()
        self.trace_done = False
        if rospy.is_shutdown():
            return
        try:
            test_status_message = 'Example #{} - Replay'.format(self.n_examples)
            self.trace_start_time = get_time()
            time_prev = self.trace_start_time
            self._update(time_now=time_prev)
            self.trace_start_time = time_prev
            mon = self.main_monitor
            rate = rospy.Rate(1000) # every 1 ms
            for event in trace:
                time_now = get_time()
                if event.timestamp > 0:
                    time_target = time_prev + event.timestamp / 1000.0
                    while time_now < time_target:
                        self._update(time_now=time_now)
                        rate.sleep()
                        time_now = get_time()
                        if request_unstuck:
                            request_unstuck = False
                            raise UnstuckRequestError()
                self._update(time_now=time_now)
                self.pub_log.append(MsgRecord(event.topic, time_now, event.msg))
                self.pubs[event.topic].publish(event.msg, time=time_now)
                time_prev = time_now
            self.trace_done = True
            self._check_status()
            time_now = get_time()
            self._update(time_now=time_now)
            # self._check_outcome(trace)
            test_status_message = 'Example #{} - Wait'.format(self.n_examples)
            while time_now < self.deadline and mon.is_falsifiable_state:
                rate.sleep()
                time_now = get_time()
                self._update(time_now=time_now)
                if request_unstuck:
                    request_unstuck = False
                    raise UnstuckRequestError()
            assert mon.verdict is not False, mon.HPL_PROPERTY
{% if main_monitor.is_existence and not main_monitor.has_scope_timeout -%}
            if mon.verdict is not True:
                self.witness = []
                assert False
{%- endif %}
            passed = True
            print("[Example #{}]: OK".format(self.n_examples))
        except AssertionError as e:
            raise e
        except EarlySuccess:
            passed = True
            print("[Example #{}]: OK".format(self.n_examples))
        except UnstuckRequestError as ure:
            passed = True
            self.assumptions_ok = False
            raise ure
        finally:
            test_status_message = 'Example #{} - Report'.format(self.n_examples)
            time_now = get_time()
            t_test = time_now - self.launch_time
            t_trace = time_now - self.trace_start_time
            t_setup = t_test - t_trace
            n = float(self.n_examples)
            self.total_time += t_test
            self.avg_time_setup = self.avg_time_setup * (n-1)/n + (t_setup / n)
            if self.assumptions_ok:
                n = float(self.n_examples - self.n_failed_assumptions)
                self.avg_time_example = self.avg_time_example * (n-1) / n
                self.avg_time_example += t_test / n
                self.avg_time_trace = self.avg_time_trace * (n-1) / n
                self.avg_time_trace += t_trace / n
                if not passed:
                    self.n_fail += 1
                    if self.first_fail is None:
                        self.first_fail = self.n_examples
                    print("[Example #{}]: FAIL".format(self.n_examples))
                if self.witness is not None:
                    self._report_witness(trace.schema)
            else:
                self.n_failed_assumptions += 1
                print("[Example #{}]: INVALID".format(self.n_examples))
            self._teardown_sut()
            test_status_message = 'Example #{} - Done'.format(self.n_examples)

{{ _eval_trace(axioms)|indent(width=4, first=true) }}

{{ _setup_test(main_monitor, monitors, axioms)|indent(width=4, first=true) }}

{{ _setup_sut(commands, settings)|indent(width=4, first=true) }}

    def _teardown_sut(self):
        global test_status_message
        with HiddenPrints():
            test_status_message = 'Teardown SUT (launch shutdown)'
            for launch in self.launches:
                launch.shutdown()
            try:
                test_status_message = 'Teardown SUT (kill nodes)'
                kill_nodes(self.NODES)
            except ROSNodeException as e:
                if e.message.startswith("Unknown node"):
                    pass
                else:
                    raise e
        for sub in self.subs.values():
            sub.reset()
        self._wait_for_nodes(online=False)
        rospy.sleep(1.0)

    def _update(self, time_now=None):
        if rospy.is_shutdown():
            raise InconclusiveTestError.rospy_shutdown()
        for launch in self.launches:
            launch.spin_once()
        if time_now is None:
            time_now = get_time()
        for monitor in self.monitors:
            monitor.on_timer(time_now)
        for monitor in self.axioms:
            monitor.on_timer(time_now)

{# {{ _check_outcome(is_liveness)|indent(width=4, first=true) }} #}

    def _on_early_success(self, time, witness):
        # called only for the main monitor
        raise EarlySuccess()

    def _on_property_violation(self, monitor, is_axiom, time, witness):
        self.witness = witness
        self.fail_time = time
        if is_axiom:
            self.assumptions_ok = False
            assume(False)
        else:
            assert False, monitor.HPL_PROPERTY

    def _on_enter_scope(self, time):
        # called only for the main monitor
        self.n_scopes += 1
        self.monitor_active = True

    def _on_exit_scope(self, time):
        # called only for the main monitor
        self.monitor_active = False

    def _wait_for_nodes(self, timeout=60.0, online=True):
        global request_unstuck
        global test_status_message
        pat = 'Waiting - SUT ' + ('Online' if online else 'Offline') + ' ({})'
        if online:
            rospy.logdebug("Waiting for the SUT to start")
        else:
            rospy.logdebug("Waiting for the SUT to shut down")
        now = get_time()
        rate = rospy.Rate(20)
        test_status_message = pat.format('init clock')
        while now == 0.0 and not rospy.is_shutdown():
            rate.sleep()
            now = get_time()
            if request_unstuck:
                request_unstuck = False
                raise UnstuckRequestError()
        end = now + timeout
        pending = list(self.NODES)
        try:
            warnings.filterwarnings(action="ignore", message="unclosed", category=ResourceWarning)
        except NameError:
            pass # Python 2
        with HiddenPrints():
            test_status_message = pat.format(pending)
            while now < end and pending and not rospy.is_shutdown():
                node_name = pending.pop()
                if not rosnode_ping(node_name, max_count=1) is online:
                    pending.append(node_name)
                    rate.sleep()
                now = get_time()
                test_status_message = pat.format(pending)
                if request_unstuck:
                    request_unstuck = False
                    raise UnstuckRequestError()
        if not rospy.is_shutdown():
            if pending:
                if online:
                    raise LookupError("Failed to find nodes " + str(pending))
                else:
                    raise LookupError("Failed to kill nodes " + str(pending))
            pending = [n for n in get_node_names() if n in self.NODES]
            try:
                pending.remove("/rosout")
            except ValueError:
                pass
            try:
                pending.remove(rospy.get_name())
            except ValueError:
                pass
            if not online:
                test_status_message = pat.format(pending)
                while now < end and pending and not rospy.is_shutdown():
                    rate.sleep()
                    pending = [n for n in get_node_names() if n in self.NODES]
                    try:
                        pending.remove("/rosout")
                    except ValueError:
                        pass
                    try:
                        pending.remove(rospy.get_name())
                    except ValueError:
                        pass
                    now = get_time()
                    test_status_message = pat.format(pending)
                    if request_unstuck:
                        request_unstuck = False
                        raise UnstuckRequestError()
                if pending:
                    raise LookupError("Failed to kill nodes " + str(pending))

    def _wait_for_interfaces(self, timeout=10.0):
        global request_unstuck
        rospy.logdebug("Waiting for publishers and subscribers")
        now = get_time()
        rate = rospy.Rate(20)
        end = now + timeout
        for pub in self.pubs.values():
            if rospy.is_shutdown():
                break
            while now < end and not pub.ready and not rospy.is_shutdown():
                rate.sleep()
                now = get_time()
                if request_unstuck:
                    request_unstuck = False
                    raise UnstuckRequestError()
            if now >= end and not rospy.is_shutdown():
                raise LookupError(
                    "Failed to connect to topic: " + str(pub.resolved_name))
        for sub in self.subs.values():
            if rospy.is_shutdown():
                break
            while now < end and not sub.ready and not rospy.is_shutdown():
                rate.sleep()
                now = get_time()
                if request_unstuck:
                    request_unstuck = False
                    raise UnstuckRequestError()
            if now >= end and not rospy.is_shutdown():
                raise LookupError(
                    "Failed to connect to topic: " + str(sub.resolved_name))

    def _check_status(self):
        if not rospy.is_shutdown():
            try:
                warnings.filterwarnings(action="ignore", message="unclosed", category=ResourceWarning)
            except NameError:
                pass # Python 2
            for node_name in self.NODES:
                assert rosnode_ping(node_name, max_count=1), (
                    "Failed to find " + node_name)
            for pub in self.pubs.values():
                assert pub.ready, "Failed to find " + pub.resolved_name
            for sub in self.subs.values():
                assert sub.ready, "Failed to find " + sub.resolved_name

    def _report_witness(self, schema_num):
        self.counterexample_size = 0
        note("Counterexample from schema #" + str(schema_num))
        note("### BEGIN COUNTEREXAMPLE ###")
        if not self.witness and not self.pub_log:
            note("No messages were sent or received.")
            note("### END COUNTEREXAMPLE ###")
            return
        # Build counterexample timeline ---------------------
        ce = []
        #   1. Published messages up until a failure was registered.
        for record in self.pub_log:
            if record.timestamp > self.fail_time:
                break
            ce.append((record, True, False))
        self.counterexample_size = len(ce)
        #   2. Witness messages placed in order.
        i = 0
        for record in self.witness:
            if record.topic in self.pubs:
                # published by the test; must be somewhere
                while i < len(ce):
                    rec2 = ce[i][0]
                    i += 1
                    if rec2.timestamp != record.timestamp:
                        continue
                    if rec2.topic != record.topic:
                        continue
                    if rec2.msg != record.msg:
                        continue
                    ce[i-1] = (rec2, True, True)
                    break
                else:
                    raise BuggyTestError.bad_witness()
            else:
                # not published by the test; should not be there
                while i < len(ce):
                    rec2 = ce[i][0]
                    if rec2.timestamp >= record.timestamp:
                        ce.insert(i, (record, False, True))
                        break
                    i += 1
                else:
                    ce.append((record, False, True))
                    i += 1
        prev = None
        for record, sent, witness in ce:
            age = record.timestamp - self.launch_time
            age = "@{:,}ms".format(int(age * 1000))
            tag = "witness" if witness else "spam"
            if sent:
                note(">> {} sent {} on {}".format(age, tag, record.topic))
            else:
                note("<< {} received on {}".format(age, record.topic))
            if not prev or record.topic != prev.topic or record.msg != prev.msg:
                msg = str(record.msg) or "(empty msg)"
                note(msg)
            else:
                note("(same as above)")
            prev = record
        note("### END COUNTEREXAMPLE ###")

    def _write_json_output(self):
        filename = os.path.splitext(os.path.basename(__file__))[0] + '.json'
        try:
            with io.open(filename, "w", encoding="utf-8") as f:
                f.write(json.dumps(self.json_stats))
        except:
            pass

    def _write_csv_output(self):
        columns = (
            "Number of examples",
            "Number of failures",
            "Examples to failure",
            "Invalid examples",
            "Shrink attempts",
            "Time per example (s)",
            "Trace duration (s)",
            "Setup/Teardown time (s)",
            "Input trace size (messages)",
            "Property",
            "Script",
        )
        data = (
            str(self.n_examples),
            str(self.n_fail),
            str(self.first_fail or ''),
            str(self.n_failed_assumptions),
            str(self.n_shrinks),
            str(self.avg_time_example),
            str(self.avg_time_trace),
            str(self.avg_time_setup),
            str(self.counterexample_size),
            "{{ main_monitor.hpl_string }}",
            __file__,
        )
        filename = os.path.splitext(os.path.basename(__file__))[0] + '.csv'
        columns = ",".join(columns)
        data = ",".join(data)
        try:
            with io.open(filename, "w", encoding="utf-8") as f:
                f.write(columns + "\n" + data + "\n")
        except:
            pass
